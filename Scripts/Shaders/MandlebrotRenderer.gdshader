shader_type canvas_item;
#include "res://Scripts/Shaders/ComplexMath.gdshaderinc" // Contains your hi/lo helpers

uniform vec2 offset = vec2(0.0,0.0); // This is the screen center offset, should be dynamic
uniform float zoomFactor = 0.1;

uniform vec2 juliaPoint = vec2(0.0, 0.0);
uniform bool julia = false;

uniform bool intColoring = false;

uniform bool  usePerturb    = false;

uniform vec2  c_ref_hi;     // The hi part of C_ref for the CPU's reference orbit
uniform vec2  c_ref_lo;     // The lo part of C_ref for the CPU's reference orbit
uniform vec2  z0_ref_hi;    // The hi part of Z_0 for the CPU's reference orbit
uniform vec2  z0_ref_lo;    // The lo part of Z_0 for the CPU's reference orbit

uniform vec2  ref_Fhi[250]; // z_ref(i) hi part
uniform vec2  ref_Flo[250]; // z_ref(i) lo part
uniform vec2  ref_Jhi[250]; // ∂f/∂z at reference hi part
uniform vec2  ref_Jlo[250]; // ∂f/∂z at reference lo part
uniform vec2  ref_Khi[250]; // ∂f/∂c at reference hi part
uniform vec2  ref_Klo[250]; // ∂f/∂c at reference hi part

// IMPORTANT: This 'func' body MUST be dynamically generated by the C# side.
// For testing, hardcoding z^2+c:
vec2 func(vec2 z, vec2 c) {
    return complexAdd(complexMult(z, z), c);
}

vec3 palette(float t){
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.3, 1.1, 0.9);
    vec3 d = vec3(0.75, 0.20, 0.25);   // phase
    return a + b * cos(6.28318 * (c * t + d));
}
vec3 blend_pal(float t, float trap){
    vec3 base = palette(t);
    vec3 hsv  = hsv_to_rgb(mod(t*360.0,360.0), 0.85, 1.0);
    vec3 mix1 = mix(base, hsv, 0.5);
    float glow = clamp(1.0 - pow(trap / 256.0, 0.25), 0.0, 1.0);
    return mix1 * (0.6 + 0.4*glow);
}
bool non_finite(vec2 v) {
    return any(isnan(v)) || any(isinf(v));
}

// A threshold for when the reference orbit is considered "escaped"
// This should be somewhat larger than the normal bailout.
const float REF_BAILOUT_THRESHOLD = 1000.0; 

void fragment() {
    vec2 res = vec2(1.0/SCREEN_PIXEL_SIZE.x, 1.0/SCREEN_PIXEL_SIZE.y);
    vec2 c_pixel = transform(vec2(UV.x/SCREEN_PIXEL_SIZE.x,
                                  UV.y/SCREEN_PIXEL_SIZE.y),
                             res, zoomFactor, offset);
    
    vec2 start_z;           
    vec2 c_constant_iter;   

    if (julia) {
        start_z = c_pixel;       
        c_constant_iter = juliaPoint; 
    } else {
        start_z = vec2(0.0, 0.0);    
        c_constant_iter = c_pixel;   
    }

    // Initialize perturbation variables (hi/lo for precision)
    vec2 Delta_z_hi = vec2(0.0);
    vec2 Delta_z_lo = vec2(0.0);

    vec2 Delta_c_hi = vec2(0.0);
    vec2 Delta_c_lo = vec2(0.0);

    // Initialize the pixel's full high-precision 'z'
    vec2 current_z_pixel_hi; // The 'hi' part of the actual pixel's current z
    vec2 current_z_pixel_lo; // The 'lo' part of the actual pixel's current z

    // Temporaries for hi/lo operations
    vec2 temp_hi, temp_lo; 

    // Initialize initial values based on perturbation active state
    if (usePerturb) {
        if (!julia) { // Mandelbrot perturbation setup
            // Initial Delta_z (δz_0) is 0 for Mandelbrot
            // Initial Delta_c (δc) = c_pixel - C_ref
            sub_dl(c_pixel, vec2(0.0), c_ref_hi, c_ref_lo, Delta_c_hi, Delta_c_lo);
            
            // Pixel's initial z: Z_0 + δz_0 (which is z0_ref_hi/lo + 0)
            current_z_pixel_hi = z0_ref_hi;
            current_z_pixel_lo = z0_ref_lo;
        } else { // Julia perturbation setup
            // Initial Delta_z (δz_0) = pixel_z_0 - Z_0_ref_for_orbit
            sub_dl(c_pixel, vec2(0.0), z0_ref_hi, z0_ref_lo, Delta_z_hi, Delta_z_lo);
            // Initial Delta_c (δc) is 0 for Julia
            Delta_c_hi = vec2(0.0);
            Delta_c_lo = vec2(0.0);

            // Pixel's initial z: Z_0 + δz_0
            add_dl(z0_ref_hi, z0_ref_lo, Delta_z_hi, Delta_z_lo, current_z_pixel_hi, current_z_pixel_lo);
        }
    } else {
        // If not using perturbation, z starts at start_z (single precision)
        current_z_pixel_hi = start_z;
        current_z_pixel_lo = vec2(0.0); // No low part for single precision
    }
    
    // Single-precision variables used for bailout, smoothing, and non-perturbed path
    vec2 z = current_z_pixel_hi; // This 'z' represents the current reconstructed hi-precision value
    vec2 z_prev = z;             // Previous value for smoothing

    float trap     = 1e20;
    float mu       = 0.0;
    bool  esc      = false;
    bool  cycle    = false;

    const int MAX_ITERS = 250;
    const int MIN_ITERS = 20;
    bool mu_lock = false;

    float bailout  = 256.0;
    float eps = 1e-5;

    vec2 tortoise  = z;  // reference point for cycle detection (single precision)
    int  power     = 1;  
    int  lam       = 0;  
    int count;
    
    bool fallback_to_single_precision = false; // Flag for adaptive precision

    for (int i = 0; i < MAX_ITERS; ++i) {
        count = i;

        // --- Determine iteration path: Perturbation or Single Precision Fallback ---
        // Conditions for fallback:
        // 1. usePerturb is explicitly false
        // 2. We've already fallen back in a previous iteration
        // 3. The reference orbit itself has "escaped" (magnitude beyond threshold)
        vec2 z_ref_i_hi = ref_Fhi[i]; // Get reference z for current iteration
        // Use squared magnitude for comparison to avoid sqrt
        float ref_mag_sq = dot(z_ref_i_hi, z_ref_i_hi); 

        if (!usePerturb || fallback_to_single_precision || ref_mag_sq > REF_BAILOUT_THRESHOLD * REF_BAILOUT_THRESHOLD) {
            fallback_to_single_precision = true; // Once fallen back, stay in this mode
            z_prev = z; // Store the current single-precision z before updating
            z = func(z, c_constant_iter); // Iterate in single precision
        }
        else{ // Perturbation path
            vec2 z_ref_i_lo  = ref_Flo[i];
            vec2 dfdz_hi     = ref_Jhi[i];
            vec2 dfdz_lo     = ref_Jlo[i];
            vec2 dfdc_hi     = ref_Khi[i];
            vec2 dfdc_lo     = ref_Klo[i];
            
            // Calculate Δz_n+1 = (∂F/∂z)Δz_n + (∂F/∂c)Δc
            vec2 temp_dz_hi, temp_dz_lo;
            complexMul_dl(dfdz_hi, dfdz_lo, Delta_z_hi, Delta_z_lo, temp_dz_hi, temp_dz_lo);

            vec2 temp_dc_hi, temp_dc_lo;
            complexMul_dl(dfdc_hi, dfdc_lo, Delta_c_hi, Delta_c_lo, temp_dc_hi, temp_dc_lo);

            add_dl(temp_dz_hi, temp_dz_lo, temp_dc_hi, temp_dc_lo, Delta_z_hi, Delta_z_lo);
            
            // Reconstruct the pixel's z_n = Z_n + Δz_n in hi/lo
            z_prev = z; // Store the previous *reconstructed* z for bailout smoothing (single precision)
            add_dl(z_ref_i_hi, z_ref_i_lo, Delta_z_hi, Delta_z_lo, current_z_pixel_hi, current_z_pixel_lo);
            z = current_z_pixel_hi; // Update the single-precision 'z' for bailout and coloring
        }

        // --- Bailout and Cycle Detection (applies to the single-precision 'z') ---
        if (!usePerturb && length(z - tortoise) < eps*eps) { // Only cycle detect if NOT perturbed.
                                                            // Cycle detection for perturbation is more complex, often avoided on GPU.
            cycle = true;
            break;              
        }
        
        vec2 dzc  = z - c_constant_iter; // dzc calculated from the current 'z'
        float r2   = dot(dzc , dzc );
        trap       = min(trap, r2);

		if (non_finite(z)) {
	        esc = true;
	        if (!mu_lock){
				mu  = float(i);
			}
	        break;
    	}

        if (r2 > bailout) {
			if (!mu_lock){
				float logR_prev = log(length(z_prev));
				float logR_curr = log(length(z));
				float slope = logR_curr - logR_prev;
				slope = max(slope, 1e-7);
				float frac = (log(bailout) - logR_prev) / slope;
				mu = float(i - 1) + clamp(frac, 0.0, 1.0);
				mu_lock = true;
			}
			if (i > MIN_ITERS){
				esc = true;
           		break;
			}
        }
        
        ++lam;
        if (!usePerturb && lam == power) { // Only update tortoise if NOT perturbed
            tortoise = z;
            power   <<= 1;
            lam      = 0;
        }
    }

    if (!esc) {
		float logR_prev = log(length(z_prev));
		float logR_curr = log(length(z));
		float slope = logR_curr - logR_prev;
		slope = max(slope, 1e-7);
		float frac = (log(bailout) - logR_prev) / slope;
		float mu1 = float(count - 1) + clamp(frac, 0.0, 1.0);
        COLOR = vec4(!intColoring ? 0.0 : mu1/float(MAX_ITERS), 0.0, 0.0, 1.0);
    } else {
        float t = mu / float(MAX_ITERS);
        COLOR   = vec4(blend_pal(t, trap), 1.0);
    }
}